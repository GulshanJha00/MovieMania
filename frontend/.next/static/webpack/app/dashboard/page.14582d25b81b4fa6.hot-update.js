"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/omdb-service.ts":
/*!*****************************!*\
  !*** ./lib/omdb-service.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   omdbService: function() { return /* binding */ omdbService; }\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./lib/api.ts\");\n\nclass OMDbService {\n    // Get popular movies\n    async getPopularMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/popular\");\n    }\n    // Get top rated movies\n    async getTopRatedMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/top-rated\");\n    }\n    // Get trending movies\n    async getTrendingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/trending\");\n    }\n    // Get now playing movies\n    async getNowPlayingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/now-playing\");\n    }\n    // Get upcoming movies\n    async getUpcomingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/upcoming\");\n    }\n    // Search movies\n    async searchMovies(query) {\n        let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/search?query=\".concat(encodeURIComponent(query), \"&page=\").concat(page));\n    }\n    // Get movies by genre\n    async getMoviesByGenre(genre) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12;\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/genre/\".concat(encodeURIComponent(genre), \"?limit=\").concat(limit));\n    }\n    // Get movie details\n    async getMovieDetails(imdbId) {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/\".concat(imdbId));\n    }\n    // Get movie by title\n    async getMovieByTitle(title) {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/title/\".concat(encodeURIComponent(title)));\n    }\n    // Get genres\n    async getGenres() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/genres\");\n    }\n    // Helper function to get genre name by ID\n    getGenreName(genreId, genres) {\n        const genre = genres.find((g)=>g.id === genreId);\n        return genre ? genre.name : \"Unknown\";\n    }\n    // Helper function to get genre names by IDs\n    getGenreNames(genreIds, genres) {\n        return genreIds.map((id)=>this.getGenreName(id, genres));\n    }\n    // Helper function to format rating\n    formatRating(rating) {\n        return \"\".concat(rating.toFixed(1), \"/10\");\n    }\n    // Helper function to format duration\n    formatDuration(duration) {\n        return duration;\n    }\n    // Helper function to get year from release date\n    getYear(releaseDate) {\n        return new Date(releaseDate).getFullYear();\n    }\n    // Helper function to check if movie is recent (within last 2 years)\n    isRecentMovie(releaseDate) {\n        const movieYear = new Date(releaseDate).getFullYear();\n        const currentYear = new Date().getFullYear();\n        return currentYear - movieYear <= 2;\n    }\n    // Helper function to get movie poster URL\n    getPosterUrl(poster) {\n        if (poster.startsWith(\"http\")) {\n            return poster;\n        }\n        return poster || \"/placeholder.svg\";\n    }\n    // Helper function to get movie backdrop URL\n    getBackdropUrl(backdrop) {\n        if (backdrop.startsWith(\"http\")) {\n            return backdrop;\n        }\n        return backdrop || \"/placeholder.svg\";\n    }\n    // Helper function to get movie year range\n    getYearRange(movies) {\n        if (movies.length === 0) return {\n            min: 0,\n            max: 0\n        };\n        const years = movies.map((movie)=>movie.year);\n        return {\n            min: Math.min(...years),\n            max: Math.max(...years)\n        };\n    }\n    // Helper function to get unique genres from movies\n    getUniqueGenres(movies) {\n        const genres = new Set();\n        movies.forEach((movie)=>{\n            movie.genre.forEach((genre)=>genres.add(genre));\n        });\n        return Array.from(genres);\n    }\n    // Helper function to filter movies by rating\n    filterByRating(movies, minRating) {\n        return movies.filter((movie)=>movie.rating >= minRating);\n    }\n    // Helper function to filter movies by year\n    filterByYear(movies, year) {\n        return movies.filter((movie)=>movie.year === year);\n    }\n    // Helper function to filter movies by genre\n    filterByGenre(movies, genre) {\n        return movies.filter((movie)=>movie.genre.includes(genre));\n    }\n    // Helper function to sort movies by rating\n    sortByRating(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.rating - a.rating : a.rating - b.rating;\n        });\n    }\n    // Helper function to sort movies by year\n    sortByYear(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.year - a.year : a.year - b.year;\n        });\n    }\n    // Helper function to sort movies by popularity\n    sortByPopularity(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.popularity - a.popularity : a.popularity - b.popularity;\n        });\n    }\n    // Helper function to format box office\n    formatBoxOffice(boxOffice) {\n        if (boxOffice === \"N/A\" || !boxOffice) return \"N/A\";\n        return boxOffice;\n    }\n    // Helper function to format awards\n    formatAwards(awards) {\n        if (awards === \"N/A\" || !awards) return \"No awards information\";\n        return awards;\n    }\n    // Helper function to get movie age rating\n    getAgeRating(rated) {\n        if (rated === \"N/A\" || !rated) return \"Not Rated\";\n        return rated;\n    }\n}\nconst omdbService = new OMDbService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (omdbService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YyxJQUFJakYsY0FBYztBQUM3QywrREFBZWlGLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL29tZGItc2VydmljZS50cz80MTBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICcuL2FwaSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT01EYk1vdmllIHtcbiAgaW1kYklkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIG92ZXJ2aWV3OiBzdHJpbmc7XG4gIHBvc3Rlcjogc3RyaW5nO1xuICBiYWNrZHJvcDogc3RyaW5nO1xuICByYXRpbmc6IG51bWJlcjtcbiAgeWVhcjogbnVtYmVyO1xuICBnZW5yZTogc3RyaW5nW107XG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIGRpcmVjdG9yOiBzdHJpbmc7XG4gIGNhc3Q6IHN0cmluZ1tdO1xuICBsYW5ndWFnZTogc3RyaW5nO1xuICBjb3VudHJ5OiBzdHJpbmc7XG4gIGZlYXR1cmVkOiBib29sZWFuO1xuICBwb3B1bGFyaXR5OiBudW1iZXI7XG4gIHJlbGVhc2VEYXRlOiBzdHJpbmc7XG4gIGFkdWx0OiBib29sZWFuO1xuICB2b3RlQ291bnQ6IG51bWJlcjtcbiAgcmF0ZWQ6IHN0cmluZztcbiAgYXdhcmRzOiBzdHJpbmc7XG4gIGJveE9mZmljZTogc3RyaW5nO1xuICBwcm9kdWN0aW9uOiBzdHJpbmc7XG4gIHdlYnNpdGU6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT01EYkdlbnJlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9NRGJSZXNwb25zZSB7XG4gIG1vdmllczogT01EYk1vdmllW107XG4gIHBhZ2luYXRpb246IHtcbiAgICBjdXJyZW50UGFnZTogbnVtYmVyO1xuICAgIHRvdGFsUGFnZXM6IG51bWJlcjtcbiAgICB0b3RhbE1vdmllczogbnVtYmVyO1xuICAgIGhhc05leHQ6IGJvb2xlYW47XG4gICAgaGFzUHJldjogYm9vbGVhbjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPTURiTW92aWVEZXRhaWxzIHtcbiAgbW92aWU6IE9NRGJNb3ZpZTtcbn1cblxuY2xhc3MgT01EYlNlcnZpY2Uge1xuICAvLyBHZXQgcG9wdWxhciBtb3ZpZXNcbiAgYXN5bmMgZ2V0UG9wdWxhck1vdmllcygpOiBQcm9taXNlPE9NRGJSZXNwb25zZT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlPignL29tZGIvbW92aWVzL3BvcHVsYXInKTtcbiAgfVxuICBcblxuICAvLyBHZXQgdG9wIHJhdGVkIG1vdmllc1xuICBhc3luYyBnZXRUb3BSYXRlZE1vdmllcygpOiBQcm9taXNlPE9NRGJSZXNwb25zZT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlPignL29tZGIvbW92aWVzL3RvcC1yYXRlZCcpO1xuICB9XG5cbiAgLy8gR2V0IHRyZW5kaW5nIG1vdmllc1xuICBhc3luYyBnZXRUcmVuZGluZ01vdmllcygpOiBQcm9taXNlPE9NRGJSZXNwb25zZT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlPignL29tZGIvbW92aWVzL3RyZW5kaW5nJyk7XG4gIH1cblxuICAvLyBHZXQgbm93IHBsYXlpbmcgbW92aWVzXG4gIGFzeW5jIGdldE5vd1BsYXlpbmdNb3ZpZXMoKTogUHJvbWlzZTxPTURiUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJSZXNwb25zZT4oJy9vbWRiL21vdmllcy9ub3ctcGxheWluZycpO1xuICB9XG5cbiAgLy8gR2V0IHVwY29taW5nIG1vdmllc1xuICBhc3luYyBnZXRVcGNvbWluZ01vdmllcygpOiBQcm9taXNlPE9NRGJSZXNwb25zZT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlPignL29tZGIvbW92aWVzL3VwY29taW5nJyk7XG4gIH1cblxuICAvLyBTZWFyY2ggbW92aWVzXG4gIGFzeW5jIHNlYXJjaE1vdmllcyhxdWVyeTogc3RyaW5nLCBwYWdlID0gMSk6IFByb21pc2U8T01EYlJlc3BvbnNlICYgeyBxdWVyeTogc3RyaW5nIH0+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJSZXNwb25zZSAmIHsgcXVlcnk6IHN0cmluZyB9PihgL29tZGIvbW92aWVzL3NlYXJjaD9xdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9JnBhZ2U9JHtwYWdlfWApO1xuICB9XG5cbiAgLy8gR2V0IG1vdmllcyBieSBnZW5yZVxuICBhc3luYyBnZXRNb3ZpZXNCeUdlbnJlKGdlbnJlOiBzdHJpbmcsIGxpbWl0ID0gMTIpOiBQcm9taXNlPE9NRGJSZXNwb25zZSAmIHsgZ2VucmU6IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIGFwaVNlcnZpY2UucmVxdWVzdDxPTURiUmVzcG9uc2UgJiB7IGdlbnJlOiBzdHJpbmcgfT4oYC9vbWRiL21vdmllcy9nZW5yZS8ke2VuY29kZVVSSUNvbXBvbmVudChnZW5yZSl9P2xpbWl0PSR7bGltaXR9YCk7XG4gIH1cblxuICAvLyBHZXQgbW92aWUgZGV0YWlsc1xuICBhc3luYyBnZXRNb3ZpZURldGFpbHMoaW1kYklkOiBzdHJpbmcpOiBQcm9taXNlPE9NRGJNb3ZpZURldGFpbHM+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJNb3ZpZURldGFpbHM+KGAvb21kYi9tb3ZpZXMvJHtpbWRiSWR9YCk7XG4gIH1cblxuICAvLyBHZXQgbW92aWUgYnkgdGl0bGVcbiAgYXN5bmMgZ2V0TW92aWVCeVRpdGxlKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPE9NRGJNb3ZpZURldGFpbHM+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJNb3ZpZURldGFpbHM+KGAvb21kYi9tb3ZpZXMvdGl0bGUvJHtlbmNvZGVVUklDb21wb25lbnQodGl0bGUpfWApO1xuICB9XG5cbiAgLy8gR2V0IGdlbnJlc1xuICBhc3luYyBnZXRHZW5yZXMoKTogUHJvbWlzZTx7IGdlbnJlczogT01EYkdlbnJlW10gfT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8eyBnZW5yZXM6IE9NRGJHZW5yZVtdIH0+KCcvb21kYi9nZW5yZXMnKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZ2VucmUgbmFtZSBieSBJRFxuICBnZXRHZW5yZU5hbWUoZ2VucmVJZDogc3RyaW5nLCBnZW5yZXM6IE9NRGJHZW5yZVtdKTogc3RyaW5nIHtcbiAgICBjb25zdCBnZW5yZSA9IGdlbnJlcy5maW5kKGcgPT4gZy5pZCA9PT0gZ2VucmVJZCk7XG4gICAgcmV0dXJuIGdlbnJlID8gZ2VucmUubmFtZSA6ICdVbmtub3duJztcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgZ2VucmUgbmFtZXMgYnkgSURzXG4gIGdldEdlbnJlTmFtZXMoZ2VucmVJZHM6IHN0cmluZ1tdLCBnZW5yZXM6IE9NRGJHZW5yZVtdKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBnZW5yZUlkcy5tYXAoaWQgPT4gdGhpcy5nZXRHZW5yZU5hbWUoaWQsIGdlbnJlcykpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZvcm1hdCByYXRpbmdcbiAgZm9ybWF0UmF0aW5nKHJhdGluZzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7cmF0aW5nLnRvRml4ZWQoMSl9LzEwYDtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgZHVyYXRpb25cbiAgZm9ybWF0RHVyYXRpb24oZHVyYXRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB5ZWFyIGZyb20gcmVsZWFzZSBkYXRlXG4gIGdldFllYXIocmVsZWFzZURhdGU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHJlbGVhc2VEYXRlKS5nZXRGdWxsWWVhcigpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIG1vdmllIGlzIHJlY2VudCAod2l0aGluIGxhc3QgMiB5ZWFycylcbiAgaXNSZWNlbnRNb3ZpZShyZWxlYXNlRGF0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbW92aWVZZWFyID0gbmV3IERhdGUocmVsZWFzZURhdGUpLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgcmV0dXJuIGN1cnJlbnRZZWFyIC0gbW92aWVZZWFyIDw9IDI7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1vdmllIHBvc3RlciBVUkxcbiAgZ2V0UG9zdGVyVXJsKHBvc3Rlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAocG9zdGVyLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgcmV0dXJuIHBvc3RlcjtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3RlciB8fCAnL3BsYWNlaG9sZGVyLnN2Zyc7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1vdmllIGJhY2tkcm9wIFVSTFxuICBnZXRCYWNrZHJvcFVybChiYWNrZHJvcDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoYmFja2Ryb3Auc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICByZXR1cm4gYmFja2Ryb3A7XG4gICAgfVxuICAgIHJldHVybiBiYWNrZHJvcCB8fCAnL3BsYWNlaG9sZGVyLnN2Zyc7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1vdmllIHllYXIgcmFuZ2VcbiAgZ2V0WWVhclJhbmdlKG1vdmllczogT01EYk1vdmllW10pOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlciB9IHtcbiAgICBpZiAobW92aWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgbWluOiAwLCBtYXg6IDAgfTtcbiAgICBcbiAgICBjb25zdCB5ZWFycyA9IG1vdmllcy5tYXAobW92aWUgPT4gbW92aWUueWVhcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogTWF0aC5taW4oLi4ueWVhcnMpLFxuICAgICAgbWF4OiBNYXRoLm1heCguLi55ZWFycylcbiAgICB9O1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB1bmlxdWUgZ2VucmVzIGZyb20gbW92aWVzXG4gIGdldFVuaXF1ZUdlbnJlcyhtb3ZpZXM6IE9NRGJNb3ZpZVtdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGdlbnJlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIG1vdmllcy5mb3JFYWNoKG1vdmllID0+IHtcbiAgICAgIG1vdmllLmdlbnJlLmZvckVhY2goZ2VucmUgPT4gZ2VucmVzLmFkZChnZW5yZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdlbnJlcyk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG1vdmllcyBieSByYXRpbmdcbiAgZmlsdGVyQnlSYXRpbmcobW92aWVzOiBPTURiTW92aWVbXSwgbWluUmF0aW5nOiBudW1iZXIpOiBPTURiTW92aWVbXSB7XG4gICAgcmV0dXJuIG1vdmllcy5maWx0ZXIobW92aWUgPT4gbW92aWUucmF0aW5nID49IG1pblJhdGluZyk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG1vdmllcyBieSB5ZWFyXG4gIGZpbHRlckJ5WWVhcihtb3ZpZXM6IE9NRGJNb3ZpZVtdLCB5ZWFyOiBudW1iZXIpOiBPTURiTW92aWVbXSB7XG4gICAgcmV0dXJuIG1vdmllcy5maWx0ZXIobW92aWUgPT4gbW92aWUueWVhciA9PT0geWVhcik7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG1vdmllcyBieSBnZW5yZVxuICBmaWx0ZXJCeUdlbnJlKG1vdmllczogT01EYk1vdmllW10sIGdlbnJlOiBzdHJpbmcpOiBPTURiTW92aWVbXSB7XG4gICAgcmV0dXJuIG1vdmllcy5maWx0ZXIobW92aWUgPT4gbW92aWUuZ2VucmUuaW5jbHVkZXMoZ2VucmUpKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzb3J0IG1vdmllcyBieSByYXRpbmdcbiAgc29ydEJ5UmF0aW5nKG1vdmllczogT01EYk1vdmllW10sIG9yZGVyOiAnYXNjJyB8ICdkZXNjJyA9ICdkZXNjJyk6IE9NRGJNb3ZpZVtdIHtcbiAgICByZXR1cm4gWy4uLm1vdmllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIG9yZGVyID09PSAnZGVzYycgPyBiLnJhdGluZyAtIGEucmF0aW5nIDogYS5yYXRpbmcgLSBiLnJhdGluZztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzb3J0IG1vdmllcyBieSB5ZWFyXG4gIHNvcnRCeVllYXIobW92aWVzOiBPTURiTW92aWVbXSwgb3JkZXI6ICdhc2MnIHwgJ2Rlc2MnID0gJ2Rlc2MnKTogT01EYk1vdmllW10ge1xuICAgIHJldHVybiBbLi4ubW92aWVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09ICdkZXNjJyA/IGIueWVhciAtIGEueWVhciA6IGEueWVhciAtIGIueWVhcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBzb3J0IG1vdmllcyBieSBwb3B1bGFyaXR5XG4gIHNvcnRCeVBvcHVsYXJpdHkobW92aWVzOiBPTURiTW92aWVbXSwgb3JkZXI6ICdhc2MnIHwgJ2Rlc2MnID0gJ2Rlc2MnKTogT01EYk1vdmllW10ge1xuICAgIHJldHVybiBbLi4ubW92aWVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09ICdkZXNjJyA/IGIucG9wdWxhcml0eSAtIGEucG9wdWxhcml0eSA6IGEucG9wdWxhcml0eSAtIGIucG9wdWxhcml0eTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgYm94IG9mZmljZVxuICBmb3JtYXRCb3hPZmZpY2UoYm94T2ZmaWNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChib3hPZmZpY2UgPT09ICdOL0EnIHx8ICFib3hPZmZpY2UpIHJldHVybiAnTi9BJztcbiAgICByZXR1cm4gYm94T2ZmaWNlO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZvcm1hdCBhd2FyZHNcbiAgZm9ybWF0QXdhcmRzKGF3YXJkczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoYXdhcmRzID09PSAnTi9BJyB8fCAhYXdhcmRzKSByZXR1cm4gJ05vIGF3YXJkcyBpbmZvcm1hdGlvbic7XG4gICAgcmV0dXJuIGF3YXJkcztcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgbW92aWUgYWdlIHJhdGluZ1xuICBnZXRBZ2VSYXRpbmcocmF0ZWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHJhdGVkID09PSAnTi9BJyB8fCAhcmF0ZWQpIHJldHVybiAnTm90IFJhdGVkJztcbiAgICByZXR1cm4gcmF0ZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9tZGJTZXJ2aWNlID0gbmV3IE9NRGJTZXJ2aWNlKCk7XG5leHBvcnQgZGVmYXVsdCBvbWRiU2VydmljZTtcbiJdLCJuYW1lcyI6WyJhcGlTZXJ2aWNlIiwiT01EYlNlcnZpY2UiLCJnZXRQb3B1bGFyTW92aWVzIiwicmVxdWVzdCIsImdldFRvcFJhdGVkTW92aWVzIiwiZ2V0VHJlbmRpbmdNb3ZpZXMiLCJnZXROb3dQbGF5aW5nTW92aWVzIiwiZ2V0VXBjb21pbmdNb3ZpZXMiLCJzZWFyY2hNb3ZpZXMiLCJxdWVyeSIsInBhZ2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRNb3ZpZXNCeUdlbnJlIiwiZ2VucmUiLCJsaW1pdCIsImdldE1vdmllRGV0YWlscyIsImltZGJJZCIsImdldE1vdmllQnlUaXRsZSIsInRpdGxlIiwiZ2V0R2VucmVzIiwiZ2V0R2VucmVOYW1lIiwiZ2VucmVJZCIsImdlbnJlcyIsImZpbmQiLCJnIiwiaWQiLCJuYW1lIiwiZ2V0R2VucmVOYW1lcyIsImdlbnJlSWRzIiwibWFwIiwiZm9ybWF0UmF0aW5nIiwicmF0aW5nIiwidG9GaXhlZCIsImZvcm1hdER1cmF0aW9uIiwiZHVyYXRpb24iLCJnZXRZZWFyIiwicmVsZWFzZURhdGUiLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJpc1JlY2VudE1vdmllIiwibW92aWVZZWFyIiwiY3VycmVudFllYXIiLCJnZXRQb3N0ZXJVcmwiLCJwb3N0ZXIiLCJzdGFydHNXaXRoIiwiZ2V0QmFja2Ryb3BVcmwiLCJiYWNrZHJvcCIsImdldFllYXJSYW5nZSIsIm1vdmllcyIsImxlbmd0aCIsIm1pbiIsIm1heCIsInllYXJzIiwibW92aWUiLCJ5ZWFyIiwiTWF0aCIsImdldFVuaXF1ZUdlbnJlcyIsIlNldCIsImZvckVhY2giLCJhZGQiLCJBcnJheSIsImZyb20iLCJmaWx0ZXJCeVJhdGluZyIsIm1pblJhdGluZyIsImZpbHRlciIsImZpbHRlckJ5WWVhciIsImZpbHRlckJ5R2VucmUiLCJpbmNsdWRlcyIsInNvcnRCeVJhdGluZyIsIm9yZGVyIiwic29ydCIsImEiLCJiIiwic29ydEJ5WWVhciIsInNvcnRCeVBvcHVsYXJpdHkiLCJwb3B1bGFyaXR5IiwiZm9ybWF0Qm94T2ZmaWNlIiwiYm94T2ZmaWNlIiwiZm9ybWF0QXdhcmRzIiwiYXdhcmRzIiwiZ2V0QWdlUmF0aW5nIiwicmF0ZWQiLCJvbWRiU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/omdb-service.ts\n"));

/***/ })

});