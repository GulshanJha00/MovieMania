"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./lib/omdb-service.ts":
/*!*****************************!*\
  !*** ./lib/omdb-service.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   omdbService: function() { return /* binding */ omdbService; }\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./lib/api.ts\");\n\nclass OMDbService {\n    // Get popular movies\n    async getPopularMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/popular\");\n    }\n    // Get top rated movies\n    async getTopRatedMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/top-rated\");\n    }\n    // Get trending movies\n    async getTrendingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/trending\");\n    }\n    // Get now playing movies\n    async getNowPlayingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/now-playing\");\n    }\n    // Get upcoming movies\n    async getUpcomingMovies() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/upcoming\");\n    }\n    // Search movies\n    async searchMovies(query) {\n        let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/search?query=\".concat(encodeURIComponent(query), \"&page=\").concat(page));\n    }\n    // Get movies by genre\n    async getMoviesByGenre(genre) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 12;\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/genre/\".concat(encodeURIComponent(genre), \"?limit=\").concat(limit));\n    }\n    // Get movie details\n    async getMovieDetails(imdbId) {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/\".concat(imdbId));\n    }\n    // Get movie by title\n    async getMovieByTitle(title) {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/movies/title/\".concat(encodeURIComponent(title)));\n    }\n    // Get genres\n    async getGenres() {\n        return _api__WEBPACK_IMPORTED_MODULE_0__.apiService.request(\"/omdb/genres\");\n    }\n    // Helper function to get genre name by ID\n    getGenreName(genreId, genres) {\n        const genre = genres.find((g)=>g.id === genreId);\n        return genre ? genre.name : \"Unknown\";\n    }\n    // Helper function to get genre names by IDs\n    getGenreNames(genreIds, genres) {\n        return genreIds.map((id)=>this.getGenreName(id, genres));\n    }\n    // Helper function to format rating\n    formatRating(rating) {\n        return \"\".concat(rating.toFixed(1), \"/10\");\n    }\n    // Helper function to format duration\n    formatDuration(duration) {\n        return duration;\n    }\n    // Helper function to get year from release date\n    getYear(releaseDate) {\n        return new Date(releaseDate).getFullYear();\n    }\n    // Helper function to check if movie is recent (within last 2 years)\n    isRecentMovie(releaseDate) {\n        const movieYear = new Date(releaseDate).getFullYear();\n        const currentYear = new Date().getFullYear();\n        return currentYear - movieYear <= 2;\n    }\n    // Helper function to get movie poster URL\n    getPosterUrl(poster) {\n        if (poster.startsWith(\"http\")) {\n            return poster;\n        }\n        return poster || \"/placeholder.svg\";\n    }\n    // Helper function to get movie backdrop URL\n    getBackdropUrl(backdrop) {\n        if (backdrop.startsWith(\"http\")) {\n            return backdrop;\n        }\n        return backdrop || \"/placeholder.svg\";\n    }\n    // Helper function to get movie year range\n    getYearRange(movies) {\n        if (movies.length === 0) return {\n            min: 0,\n            max: 0\n        };\n        const years = movies.map((movie)=>movie.year);\n        return {\n            min: Math.min(...years),\n            max: Math.max(...years)\n        };\n    }\n    // Helper function to get unique genres from movies\n    getUniqueGenres(movies) {\n        const genres = new Set();\n        movies.forEach((movie)=>{\n            movie.genre.forEach((genre)=>genres.add(genre));\n        });\n        return Array.from(genres);\n    }\n    // Helper function to filter movies by rating\n    filterByRating(movies, minRating) {\n        return movies.filter((movie)=>movie.rating >= minRating);\n    }\n    // Helper function to filter movies by year\n    filterByYear(movies, year) {\n        return movies.filter((movie)=>movie.year === year);\n    }\n    // Helper function to filter movies by genre\n    filterByGenre(movies, genre) {\n        return movies.filter((movie)=>movie.genre.includes(genre));\n    }\n    // Helper function to sort movies by rating\n    sortByRating(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.rating - a.rating : a.rating - b.rating;\n        });\n    }\n    // Helper function to sort movies by year\n    sortByYear(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.year - a.year : a.year - b.year;\n        });\n    }\n    // Helper function to sort movies by popularity\n    sortByPopularity(movies) {\n        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"desc\";\n        return [\n            ...movies\n        ].sort((a, b)=>{\n            return order === \"desc\" ? b.popularity - a.popularity : a.popularity - b.popularity;\n        });\n    }\n    // Helper function to format box office\n    formatBoxOffice(boxOffice) {\n        if (boxOffice === \"N/A\" || !boxOffice) return \"N/A\";\n        return boxOffice;\n    }\n    // Helper function to format awards\n    formatAwards(awards) {\n        if (awards === \"N/A\" || !awards) return \"No awards information\";\n        return awards;\n    }\n    // Helper function to get movie age rating\n    getAgeRating(rated) {\n        if (rated === \"N/A\" || !rated) return \"Not Rated\";\n        return rated;\n    }\n}\nconst omdbService = new OMDbService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (omdbService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YyxJQUFJakYsY0FBYztBQUM3QywrREFBZWlGLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL29tZGItc2VydmljZS50cz80MTBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICcuL2FwaSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT01EYk1vdmllIHtcbiAgaW1kYklkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIG92ZXJ2aWV3OiBzdHJpbmc7XG4gIHBvc3Rlcjogc3RyaW5nO1xuICBiYWNrZHJvcDogc3RyaW5nO1xuICByYXRpbmc6IG51bWJlcjtcbiAgeWVhcjogbnVtYmVyO1xuICBnZW5yZTogc3RyaW5nW107XG4gIGR1cmF0aW9uOiBzdHJpbmc7XG4gIGRpcmVjdG9yOiBzdHJpbmc7XG4gIGNhc3Q6IHN0cmluZ1tdO1xuICBsYW5ndWFnZTogc3RyaW5nO1xuICBjb3VudHJ5OiBzdHJpbmc7XG4gIGZlYXR1cmVkOiBib29sZWFuO1xuICBwb3B1bGFyaXR5OiBudW1iZXI7XG4gIHJlbGVhc2VEYXRlOiBzdHJpbmc7XG4gIGFkdWx0OiBib29sZWFuO1xuICB2b3RlQ291bnQ6IG51bWJlcjtcbiAgcmF0ZWQ6IHN0cmluZztcbiAgYXdhcmRzOiBzdHJpbmc7XG4gIGJveE9mZmljZTogc3RyaW5nO1xuICBwcm9kdWN0aW9uOiBzdHJpbmc7XG4gIHdlYnNpdGU6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT01EYkdlbnJlIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9NRGJSZXNwb25zZSB7XG4gIG1vdmllczogT01EYk1vdmllW107XG4gIHBhZ2luYXRpb246IHtcbiAgICBjdXJyZW50UGFnZTogbnVtYmVyO1xuICAgIHRvdGFsUGFnZXM6IG51bWJlcjtcbiAgICB0b3RhbE1vdmllczogbnVtYmVyO1xuICAgIGhhc05leHQ6IGJvb2xlYW47XG4gICAgaGFzUHJldjogYm9vbGVhbjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPTURiTW92aWVEZXRhaWxzIHtcbiAgbW92aWU6IE9NRGJNb3ZpZTtcbn1cblxuY2xhc3MgT01EYlNlcnZpY2Uge1xuICAvLyBHZXQgcG9wdWxhciBtb3ZpZXNcbiAgYXN5bmMgZ2V0UG9wdWxhck1vdmllcygpOiBQcm9taXNlPE9NRGJSZXNwb25zZT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlPignL29tZGIvbW92aWVzL3BvcHVsYXInKTtcbiAgfVxuICBcbiAgXG5cbiAgLy8gR2V0IHRvcCByYXRlZCBtb3ZpZXNcbiAgYXN5bmMgZ2V0VG9wUmF0ZWRNb3ZpZXMoKTogUHJvbWlzZTxPTURiUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJSZXNwb25zZT4oJy9vbWRiL21vdmllcy90b3AtcmF0ZWQnKTtcbiAgfVxuXG4gIC8vIEdldCB0cmVuZGluZyBtb3ZpZXNcbiAgYXN5bmMgZ2V0VHJlbmRpbmdNb3ZpZXMoKTogUHJvbWlzZTxPTURiUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJSZXNwb25zZT4oJy9vbWRiL21vdmllcy90cmVuZGluZycpO1xuICB9XG5cbiAgLy8gR2V0IG5vdyBwbGF5aW5nIG1vdmllc1xuICBhc3luYyBnZXROb3dQbGF5aW5nTW92aWVzKCk6IFByb21pc2U8T01EYlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGFwaVNlcnZpY2UucmVxdWVzdDxPTURiUmVzcG9uc2U+KCcvb21kYi9tb3ZpZXMvbm93LXBsYXlpbmcnKTtcbiAgfVxuXG4gIC8vIEdldCB1cGNvbWluZyBtb3ZpZXNcbiAgYXN5bmMgZ2V0VXBjb21pbmdNb3ZpZXMoKTogUHJvbWlzZTxPTURiUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PE9NRGJSZXNwb25zZT4oJy9vbWRiL21vdmllcy91cGNvbWluZycpO1xuICB9XG5cbiAgLy8gU2VhcmNoIG1vdmllc1xuICBhc3luYyBzZWFyY2hNb3ZpZXMocXVlcnk6IHN0cmluZywgcGFnZSA9IDEpOiBQcm9taXNlPE9NRGJSZXNwb25zZSAmIHsgcXVlcnk6IHN0cmluZyB9PiB7XG4gICAgcmV0dXJuIGFwaVNlcnZpY2UucmVxdWVzdDxPTURiUmVzcG9uc2UgJiB7IHF1ZXJ5OiBzdHJpbmcgfT4oYC9vbWRiL21vdmllcy9zZWFyY2g/cXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnkpfSZwYWdlPSR7cGFnZX1gKTtcbiAgfVxuXG4gIC8vIEdldCBtb3ZpZXMgYnkgZ2VucmVcbiAgYXN5bmMgZ2V0TW92aWVzQnlHZW5yZShnZW5yZTogc3RyaW5nLCBsaW1pdCA9IDEyKTogUHJvbWlzZTxPTURiUmVzcG9uc2UgJiB7IGdlbnJlOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiBhcGlTZXJ2aWNlLnJlcXVlc3Q8T01EYlJlc3BvbnNlICYgeyBnZW5yZTogc3RyaW5nIH0+KGAvb21kYi9tb3ZpZXMvZ2VucmUvJHtlbmNvZGVVUklDb21wb25lbnQoZ2VucmUpfT9saW1pdD0ke2xpbWl0fWApO1xuICB9XG5cbiAgLy8gR2V0IG1vdmllIGRldGFpbHNcbiAgYXN5bmMgZ2V0TW92aWVEZXRhaWxzKGltZGJJZDogc3RyaW5nKTogUHJvbWlzZTxPTURiTW92aWVEZXRhaWxzPiB7XG4gICAgcmV0dXJuIGFwaVNlcnZpY2UucmVxdWVzdDxPTURiTW92aWVEZXRhaWxzPihgL29tZGIvbW92aWVzLyR7aW1kYklkfWApO1xuICB9XG5cbiAgLy8gR2V0IG1vdmllIGJ5IHRpdGxlXG4gIGFzeW5jIGdldE1vdmllQnlUaXRsZSh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxPTURiTW92aWVEZXRhaWxzPiB7XG4gICAgcmV0dXJuIGFwaVNlcnZpY2UucmVxdWVzdDxPTURiTW92aWVEZXRhaWxzPihgL29tZGIvbW92aWVzL3RpdGxlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRpdGxlKX1gKTtcbiAgfVxuXG4gIC8vIEdldCBnZW5yZXNcbiAgYXN5bmMgZ2V0R2VucmVzKCk6IFByb21pc2U8eyBnZW5yZXM6IE9NRGJHZW5yZVtdIH0+IHtcbiAgICByZXR1cm4gYXBpU2VydmljZS5yZXF1ZXN0PHsgZ2VucmVzOiBPTURiR2VucmVbXSB9PignL29tZGIvZ2VucmVzJyk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGdlbnJlIG5hbWUgYnkgSURcbiAgZ2V0R2VucmVOYW1lKGdlbnJlSWQ6IHN0cmluZywgZ2VucmVzOiBPTURiR2VucmVbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2VucmUgPSBnZW5yZXMuZmluZChnID0+IGcuaWQgPT09IGdlbnJlSWQpO1xuICAgIHJldHVybiBnZW5yZSA/IGdlbnJlLm5hbWUgOiAnVW5rbm93bic7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGdlbnJlIG5hbWVzIGJ5IElEc1xuICBnZXRHZW5yZU5hbWVzKGdlbnJlSWRzOiBzdHJpbmdbXSwgZ2VucmVzOiBPTURiR2VucmVbXSk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gZ2VucmVJZHMubWFwKGlkID0+IHRoaXMuZ2V0R2VucmVOYW1lKGlkLCBnZW5yZXMpKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgcmF0aW5nXG4gIGZvcm1hdFJhdGluZyhyYXRpbmc6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3JhdGluZy50b0ZpeGVkKDEpfS8xMGA7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGR1cmF0aW9uXG4gIGZvcm1hdER1cmF0aW9uKGR1cmF0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgeWVhciBmcm9tIHJlbGVhc2UgZGF0ZVxuICBnZXRZZWFyKHJlbGVhc2VEYXRlOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiBuZXcgRGF0ZShyZWxlYXNlRGF0ZSkuZ2V0RnVsbFllYXIoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBtb3ZpZSBpcyByZWNlbnQgKHdpdGhpbiBsYXN0IDIgeWVhcnMpXG4gIGlzUmVjZW50TW92aWUocmVsZWFzZURhdGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG1vdmllWWVhciA9IG5ldyBEYXRlKHJlbGVhc2VEYXRlKS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgIHJldHVybiBjdXJyZW50WWVhciAtIG1vdmllWWVhciA8PSAyO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtb3ZpZSBwb3N0ZXIgVVJMXG4gIGdldFBvc3RlclVybChwb3N0ZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHBvc3Rlci5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgIHJldHVybiBwb3N0ZXI7XG4gICAgfVxuICAgIHJldHVybiBwb3N0ZXIgfHwgJy9wbGFjZWhvbGRlci5zdmcnO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtb3ZpZSBiYWNrZHJvcCBVUkxcbiAgZ2V0QmFja2Ryb3BVcmwoYmFja2Ryb3A6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGJhY2tkcm9wLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgcmV0dXJuIGJhY2tkcm9wO1xuICAgIH1cbiAgICByZXR1cm4gYmFja2Ryb3AgfHwgJy9wbGFjZWhvbGRlci5zdmcnO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtb3ZpZSB5ZWFyIHJhbmdlXG4gIGdldFllYXJSYW5nZShtb3ZpZXM6IE9NRGJNb3ZpZVtdKTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gICAgaWYgKG1vdmllcy5sZW5ndGggPT09IDApIHJldHVybiB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgXG4gICAgY29uc3QgeWVhcnMgPSBtb3ZpZXMubWFwKG1vdmllID0+IG1vdmllLnllYXIpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IE1hdGgubWluKC4uLnllYXJzKSxcbiAgICAgIG1heDogTWF0aC5tYXgoLi4ueWVhcnMpXG4gICAgfTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdW5pcXVlIGdlbnJlcyBmcm9tIG1vdmllc1xuICBnZXRVbmlxdWVHZW5yZXMobW92aWVzOiBPTURiTW92aWVbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBnZW5yZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBtb3ZpZXMuZm9yRWFjaChtb3ZpZSA9PiB7XG4gICAgICBtb3ZpZS5nZW5yZS5mb3JFYWNoKGdlbnJlID0+IGdlbnJlcy5hZGQoZ2VucmUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShnZW5yZXMpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbHRlciBtb3ZpZXMgYnkgcmF0aW5nXG4gIGZpbHRlckJ5UmF0aW5nKG1vdmllczogT01EYk1vdmllW10sIG1pblJhdGluZzogbnVtYmVyKTogT01EYk1vdmllW10ge1xuICAgIHJldHVybiBtb3ZpZXMuZmlsdGVyKG1vdmllID0+IG1vdmllLnJhdGluZyA+PSBtaW5SYXRpbmcpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbHRlciBtb3ZpZXMgYnkgeWVhclxuICBmaWx0ZXJCeVllYXIobW92aWVzOiBPTURiTW92aWVbXSwgeWVhcjogbnVtYmVyKTogT01EYk1vdmllW10ge1xuICAgIHJldHVybiBtb3ZpZXMuZmlsdGVyKG1vdmllID0+IG1vdmllLnllYXIgPT09IHllYXIpO1xuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGZpbHRlciBtb3ZpZXMgYnkgZ2VucmVcbiAgZmlsdGVyQnlHZW5yZShtb3ZpZXM6IE9NRGJNb3ZpZVtdLCBnZW5yZTogc3RyaW5nKTogT01EYk1vdmllW10ge1xuICAgIHJldHVybiBtb3ZpZXMuZmlsdGVyKG1vdmllID0+IG1vdmllLmdlbnJlLmluY2x1ZGVzKGdlbnJlKSk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc29ydCBtb3ZpZXMgYnkgcmF0aW5nXG4gIHNvcnRCeVJhdGluZyhtb3ZpZXM6IE9NRGJNb3ZpZVtdLCBvcmRlcjogJ2FzYycgfCAnZGVzYycgPSAnZGVzYycpOiBPTURiTW92aWVbXSB7XG4gICAgcmV0dXJuIFsuLi5tb3ZpZXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBvcmRlciA9PT0gJ2Rlc2MnID8gYi5yYXRpbmcgLSBhLnJhdGluZyA6IGEucmF0aW5nIC0gYi5yYXRpbmc7XG4gICAgfSk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc29ydCBtb3ZpZXMgYnkgeWVhclxuICBzb3J0QnlZZWFyKG1vdmllczogT01EYk1vdmllW10sIG9yZGVyOiAnYXNjJyB8ICdkZXNjJyA9ICdkZXNjJyk6IE9NRGJNb3ZpZVtdIHtcbiAgICByZXR1cm4gWy4uLm1vdmllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIG9yZGVyID09PSAnZGVzYycgPyBiLnllYXIgLSBhLnllYXIgOiBhLnllYXIgLSBiLnllYXI7XG4gICAgfSk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc29ydCBtb3ZpZXMgYnkgcG9wdWxhcml0eVxuICBzb3J0QnlQb3B1bGFyaXR5KG1vdmllczogT01EYk1vdmllW10sIG9yZGVyOiAnYXNjJyB8ICdkZXNjJyA9ICdkZXNjJyk6IE9NRGJNb3ZpZVtdIHtcbiAgICByZXR1cm4gWy4uLm1vdmllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIG9yZGVyID09PSAnZGVzYycgPyBiLnBvcHVsYXJpdHkgLSBhLnBvcHVsYXJpdHkgOiBhLnBvcHVsYXJpdHkgLSBiLnBvcHVsYXJpdHk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGJveCBvZmZpY2VcbiAgZm9ybWF0Qm94T2ZmaWNlKGJveE9mZmljZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoYm94T2ZmaWNlID09PSAnTi9BJyB8fCAhYm94T2ZmaWNlKSByZXR1cm4gJ04vQSc7XG4gICAgcmV0dXJuIGJveE9mZmljZTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmb3JtYXQgYXdhcmRzXG4gIGZvcm1hdEF3YXJkcyhhd2FyZHM6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGF3YXJkcyA9PT0gJ04vQScgfHwgIWF3YXJkcykgcmV0dXJuICdObyBhd2FyZHMgaW5mb3JtYXRpb24nO1xuICAgIHJldHVybiBhd2FyZHM7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1vdmllIGFnZSByYXRpbmdcbiAgZ2V0QWdlUmF0aW5nKHJhdGVkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChyYXRlZCA9PT0gJ04vQScgfHwgIXJhdGVkKSByZXR1cm4gJ05vdCBSYXRlZCc7XG4gICAgcmV0dXJuIHJhdGVkO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvbWRiU2VydmljZSA9IG5ldyBPTURiU2VydmljZSgpO1xuZXhwb3J0IGRlZmF1bHQgb21kYlNlcnZpY2U7XG4iXSwibmFtZXMiOlsiYXBpU2VydmljZSIsIk9NRGJTZXJ2aWNlIiwiZ2V0UG9wdWxhck1vdmllcyIsInJlcXVlc3QiLCJnZXRUb3BSYXRlZE1vdmllcyIsImdldFRyZW5kaW5nTW92aWVzIiwiZ2V0Tm93UGxheWluZ01vdmllcyIsImdldFVwY29taW5nTW92aWVzIiwic2VhcmNoTW92aWVzIiwicXVlcnkiLCJwYWdlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0TW92aWVzQnlHZW5yZSIsImdlbnJlIiwibGltaXQiLCJnZXRNb3ZpZURldGFpbHMiLCJpbWRiSWQiLCJnZXRNb3ZpZUJ5VGl0bGUiLCJ0aXRsZSIsImdldEdlbnJlcyIsImdldEdlbnJlTmFtZSIsImdlbnJlSWQiLCJnZW5yZXMiLCJmaW5kIiwiZyIsImlkIiwibmFtZSIsImdldEdlbnJlTmFtZXMiLCJnZW5yZUlkcyIsIm1hcCIsImZvcm1hdFJhdGluZyIsInJhdGluZyIsInRvRml4ZWQiLCJmb3JtYXREdXJhdGlvbiIsImR1cmF0aW9uIiwiZ2V0WWVhciIsInJlbGVhc2VEYXRlIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiaXNSZWNlbnRNb3ZpZSIsIm1vdmllWWVhciIsImN1cnJlbnRZZWFyIiwiZ2V0UG9zdGVyVXJsIiwicG9zdGVyIiwic3RhcnRzV2l0aCIsImdldEJhY2tkcm9wVXJsIiwiYmFja2Ryb3AiLCJnZXRZZWFyUmFuZ2UiLCJtb3ZpZXMiLCJsZW5ndGgiLCJtaW4iLCJtYXgiLCJ5ZWFycyIsIm1vdmllIiwieWVhciIsIk1hdGgiLCJnZXRVbmlxdWVHZW5yZXMiLCJTZXQiLCJmb3JFYWNoIiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyQnlSYXRpbmciLCJtaW5SYXRpbmciLCJmaWx0ZXIiLCJmaWx0ZXJCeVllYXIiLCJmaWx0ZXJCeUdlbnJlIiwiaW5jbHVkZXMiLCJzb3J0QnlSYXRpbmciLCJvcmRlciIsInNvcnQiLCJhIiwiYiIsInNvcnRCeVllYXIiLCJzb3J0QnlQb3B1bGFyaXR5IiwicG9wdWxhcml0eSIsImZvcm1hdEJveE9mZmljZSIsImJveE9mZmljZSIsImZvcm1hdEF3YXJkcyIsImF3YXJkcyIsImdldEFnZVJhdGluZyIsInJhdGVkIiwib21kYlNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/omdb-service.ts\n"));

/***/ })

});